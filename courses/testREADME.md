<t->***代码说明***

1. <nt->`"encoding/json"`包可用于操作 `io.Reader` 数据流中携带的 `json` 的数据。

2. <nt->`NewDecoder`方法是创建一个新的 `json` 解码器 ， 并且将 `io.Reader` 数据流作为参数 ，这样解码器就知道从什么地方读取数据啦~

3. <nt->解码器是 `*json.Decoder` 类型 ， 并且使用 `Decode` 对数据流中携带的 `json` 数据解析到GO的结构体中。

    * <t-->此处我们使用了 `User` 这个结构体去接收 ， 用实体 `user` 来存储接收到的信息。

    * <t-->`Decode`这个方法有一个 `error` 类型的返回值 ， 用于检测是否正确读取了 `json` 数据。
   
    * >数据流中的 `json` 数据跟结构体中定义 `json:""` 是一一对应的，也就是说 `json` 数据流中拥有名称"userid",那么当解码器对数据流进行解码时，会映射到`json:"userid"`的字段中。
      
4. <nt->最后就能使用user的实体属性来使用 `json` 数据流中的数据啦！

::: tip 总结
***恭喜你完成了这段代码的学习，你能正常获取到前端发来的信息啦！在前后端通信中，已经迈出了很大的一步，想要验证这个信息是否符合您的要求？快来学习下一节吧~***
:::